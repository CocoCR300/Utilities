#!/usr/bin/env python3


# TODO: List the different wireless interfaces with `wpa_cli interface` if there is more than one

# TODO: Allow to "open a hotspot":
# FreeBSD can act as an Access Point (AP) which eliminates the need to buy a hardware AP or run an ad-hoc network.
# This can be particularly useful when a FreeBSD machine is acting as a gateway to another network such as the Internet.
# https://vzaigrin.wordpress.com/2014/08/04/how-to-setup-wireless-access-point-on-raspberry-pi-running-freebsd/
# https://github.com/opnsense/src/blob/master/tools/tools/net80211/scripts/setup.simple2
# "WPA2 Host-based Access Point"
# https://docs.freebsd.org/en/books/handbook/advanced-networking/#network-wireless


from PyQt5.QtWidgets import QApplication, QSystemTrayIcon, QMenu, QAction, QHBoxLayout, QWidget, QActionGroup, \
    QMessageBox, QLineEdit, QStyle, QStyleOptionMenuItem, QLabel, QWidgetAction, QProxyStyle, QDialog, \
    QGridLayout, QLayout, QCheckBox, QPushButton, QSizePolicy
from PyQt5.QtGui import QIcon, QPixmap, QCursor, QPainter, QPaintEvent
from PyQt5.QtCore import Qt, QProcess, QObject, QTimer, QSize
from subprocess import Popen, check_output
import sys, os, re, subprocess


def get_icon_for_signal_level(signal_level: int) -> str:
    # https://github.com/maxatome/wifimgr/blob/ca9951f0c08a72ad3f36c98a970414219d5b9b03/src/wifimgr-gtk.c#L1312
    if signal_level > 80:
        icon_name = "network-wireless-100"
    elif signal_level > 60:
        icon_name = "network-wireless-75"
    elif signal_level > 40:
        icon_name = "network-wireless-50"
    elif signal_level > 20:
        icon_name = "network-wireless-25"
    elif signal_level > 0:
        icon_name = "network-wireless-00"
    else:
        icon_name = "network-wireless-00"

    return icon_name


def get_network_signal_level(bssid: str) -> int:
    p = QProcess()
    p.setProgram("wpa_cli")
    p.setArguments(["bss", bssid])
    p.start()
    p.waitForFinished()
    lines = str(p.readAllStandardOutput(), 'utf-8').strip().splitlines()

    signal_strength_dbm = 0
    signal_noise_dbm = 0
    for line in lines:
        if line.startswith("noise="):
            signal_noise_dbm = int(line.split("=")[1])
            continue
        if line.startswith("level="):
            signal_strength_dbm = int(line.split("=")[1])
            break

    # https://github.com/maxatome/wifimgr/blob/ca9951f0c08a72ad3f36c98a970414219d5b9b03/src/wifimgr.c#L848
    return (signal_strength_dbm - signal_noise_dbm) * 4


class NetworkMenu(QObject):

    def __init__(self):

        super().__init__()

        # self.showTODO("It can show wireless networks but not connect to them. Do you know how to fix this?")
        self.showTODO()

        self.tray = QSystemTrayIcon()

        self.tray.setVisible(True)
        self.menu = QMenu()
        self.wirelessGroup = QActionGroup(self.menu)  # Only one of the actions added to this group can be active

        self.tray.setContextMenu(self.menu)
        self.tray.activated.connect(self.show_menu)

        # NOTE:
        # https://forum.learnpyqt.com/t/qsystemtrayicon-example/689
        # Sneaky PyQt quirk! A reference to the actions must be kept around or the actions will be destroyed
        self.actions = []
        self.sliderWindow = None
        self.check_network_password = False
        self.updateStatus()
        
        self.timer = QTimer()
        self.timer.setInterval(3000) # Every 3 seconds
        self.timer.timeout.connect(self.updateStatus)
        self.timer.start()

        self.refreshMenu() # Initially populate the menu
        self.tray.installEventFilter(self) # FIXME: This never seems to get called, why?
        self.installEventFilter(self)  # FIXME: This never seems to get called, why?

    def eventFilter(self, obj, event) -> bool:
        print("eventFilter function running") # FIXME: Why is this never called when the icon is right-clicked?
        # We need to refresh the contents of the right-click menu somehow when the user right-clicks...
        return super().eventFilter(obj, event)

    def show_menu(self, reason):
        self.updateMenu()
        if reason == QSystemTrayIcon.Trigger:
            # Ideally we would just tell it when it gets left-clicked
            # to just do whatever it does when it gets right-clicked, but:
            # self.tray.activated(QSystemTrayIcon.Context) # TypeError: native Qt signal is not callable
            print(self.tray.geometry().getRect()) # Always returns (0, 0, 0, 0); why?
            # self.menu.popup(QPoint(self.tray.geometry().x(), self.tray.geometry().y())) # Does not work for the same reason
            # self.menu.move(QCursor.pos())
            # self.menu.show() # When called like this, it appears as a context menu over the menu bar, which is not desired
            # self.menu.activateWindow() # Needed on some systems to make the menu go away when clicked anywhere else but in the menu?
            self.menu.popup(QCursor.pos()) # When called like this, it appears almost at the correct location but with the wrong font size,
            # as if it was a context menu rather than a real menu; probably because somehow its parent now is not the global menu bar main window?


    def refreshMenu(self):
        self.actions = []
        # Get the networks from wpa_cli
        p = QProcess()
        p.setProgram("wpa_cli")

        # First, scan
        p.setArguments(["scan"])
        print(p.program() + " " + " ".join(p.arguments()))
        p.start()
        p.waitForFinished()

    def updateStatus(self):
        bssid = ""
        status = ""
        p = QProcess()
        p.setProgram("wpa_cli")
        p.setArguments(["status"])
        print(p.program() + " " + " ".join(p.arguments()))
        p.start()
        p.waitForFinished()

        self.status_lines = str(p.readAllStandardOutput(), 'utf-8').strip().splitlines()
        
        print(self.status_lines)
        
        # Update the icon in the menu
        for element in self.status_lines:
            if element.startswith("bssid="):
                bssid = element.split("=")[1]
                continue

            if element.startswith("wpa_state="):
                status = element.split("=")[1]
                break

        if status == "SCANNING":
            if self.wirelessGroup.checkedAction() is not None:
                flags = getattr(self.wirelessGroup.checkedAction(), "flags")
                if self.check_network_password:
                    self.set_network_password()
                    self.reconnect()

            self.tray.setIcon(QIcon.fromTheme("network-wireless-acquiring-symbolic"))
        elif status == "COMPLETED":
            self.check_network_password = False

            signal_level = get_network_signal_level(bssid)
            print('Signal level: %s' % signal_level)
            self.tray.setIcon(QIcon.fromTheme(get_icon_for_signal_level(signal_level)))
        else:
            self.tray.setIcon(QIcon.fromTheme("network-wireless-disconnected"))

        if not self.menu.isHidden():
            for action in self.menu.actions():
                if hasattr(action, "bssid"):
                    bssid = getattr(action, "bssid")
                    flags = getattr(action, "flags")
                    action.defaultWidget().set_signal_level(get_network_signal_level(bssid))
                    # TODO: Those flags are not updating
                    action.defaultWidget().set_password_protected("PSK" in flags)
             
    def updateMenu(self):
    
        # Find out whether we are connected to one of the networks
        self.updateStatus()
    
        self.menu.clear()
        # Second, show
        p = QProcess()
        p.setProgram("wpa_cli")
        p.setArguments(["scan_results"])
        print(p.program() + " " + " ".join(p.arguments()))
        p.start()
        p.waitForFinished()

        lines = str(p.readAllStandardOutput(), 'utf-8').strip().splitlines()

        action = QAction("Wireless")
        action.setDisabled(True)
        self.actions.append(action)
        self.menu.addAction(action)
        
        if len(lines) > 1:
            ssids_added_to_menu = []
            for line in lines:
                if line.startswith("Selected") or line.startswith("bssid"):
                    continue
                print(line)
                # Parse out information for each network
                regex = r"([^\ ]+)\t[^\ ]+\t[^\ ]+\t([^\ ]+)\t(.*)$"
                matches = re.findall(regex, line)
                if not matches:
                    continue
                print(len(matches[0]))
                bssid = matches[0][0]
                flags = matches[0][1]
                label = matches[0][2]
                signal_level = get_network_signal_level(bssid)

                ssid = label
                if label == "" or label.startswith("\\x00"):
                    label = bssid  # For networks with hidden ssid (network name)
                action = QWidgetAction(self.menu)
                action.__setattr__("ssid", ssid)
                action.__setattr__("bssid", bssid)
                # if 'flags' in vars():
                action.__setattr__("flags", flags)
                action.triggered.connect(self.switchNetwork)  # lambda could be used to pass an argument but the argument passed is taken at the time when this executes, which is not what we want
                action.setCheckable(True)
                action.setText(label)

                #item = NetworkItem(self.menu, action, label, "ssid=" + ssid in self.status_lines, "PSK" in flags)
                item = NetworkItem(self.menu, action, "PSK" in flags)
                action.setDefaultWidget(item)

                if "ssid=" + ssid in self.status_lines:
                    action.setChecked(True)

                # TODO: Show networks with same SSID but different BSSID
                if ssid not in ssids_added_to_menu:
                    self.actions.append(action)
                    self.wirelessGroup.addAction(action)
                    self.menu.addAction(action)
                    ssids_added_to_menu.append(ssid)

        self.menu.addSeparator()

        action = QAction("Rescan Networks")
        # action.setDisabled(True)
        action.triggered.connect(self.refreshMenu)
        self.actions.append(action)
        self.menu.addAction(action)

        action = QAction("Create Hotspot...")  # TODO: To be implemented
        action.setDisabled(True)
        self.actions.append(action)
        self.menu.addAction(action)

        action = QAction("Disconnect")
        if "wpa_state=COMPLETED" in self.status_lines:
            action.setDisabled(False)
        else:
            action.setDisabled(True)
        action.triggered.connect(self.disconnect)
        self.actions.append(action)
        self.menu.addAction(action)

        self.menu.addSeparator()

        action = QAction("About")
        action.triggered.connect(self._showAbout)
        self.actions.append(action)
        self.menu.addAction(action)

    def reconnect(self):
        p = QProcess()
        p.setProgram("wpa_cli")
        p.setArguments(["reconnect"])
        print(p.program() + " " + " ".join(p.arguments()))
        p.start()
        p.waitForFinished()
        output = str(p.readAllStandardOutput(), 'utf-8')
        print(output)
         
    def disconnect(self):
        p = QProcess()
        p.setProgram("wpa_cli")
        p.setArguments(["disconnect"])
        print(p.program() + " " + " ".join(p.arguments()))
        p.start()
        p.waitForFinished()
        output = str(p.readAllStandardOutput(), 'utf-8')
        print(output)
        self.tray.setIcon(QIcon.fromTheme("network-wireless-offline-symbolic"))
        
    def switchNetwork(self, line):
        self.check_network_password = False
        self.updateStatus()
    
        ssid = getattr(self.wirelessGroup.checkedAction(), "ssid")
        bssid = getattr(self.wirelessGroup.checkedAction(), "bssid")
        flags = getattr(self.wirelessGroup.checkedAction(), "flags")
        
        # self.reconnect()
            
        # Get a byte string with wpa_cli's output and decode it
        p = QProcess()
        p.setProgram("wpa_cli")

        # First, scan
        p.setArguments(["list_networks"])
        print(p.program() + " " + " ".join(p.arguments()))
        p.start()
        p.waitForFinished()
        # Split that output into lines, ignoring the useless ones
        output = str(p.readAllStandardOutput(), 'utf-8').strip().splitlines()
        if len(output) < 2:
            # If this is called, something is wrong with wpa_cli.
            self.showError("Could not connect to the network", """For some reason wpa_cli doesn't seem to be working.

Information for debuggers:
""" + output.strip())
            return
        is_used = False
        for line in output[2:]: # Ignore 'selected interface' message and column labels
            parts = line.split('\t')
            if parts[1] in [ssid, bssid]:
                is_used = True
                self.network_id = parts[0]
                continue

        if is_used: # TODO: We know we've already connected -- check why we are re-connecting
            if "PSK" in flags:
                self.check_network_password = True
            else:
                # Synchronize current network configuration with configuration file
                p.setArguments(["set_network", str(self.network_id), "key_mgmt", "NONE"])
                p.start()
                p.waitForFinished()

                p.setArguments(["save_config"])
                p.start()
                p.waitForFinished()

            p.setArguments(["select_network", str(self.network_id)])
            p.start()
            p.waitForFinished()
        else:
            p.setArguments(["add_network"])
            print(p.program() + " " + " ".join(p.arguments()))
            p.start()
            p.waitForFinished()
            e = str(p.readAllStandardOutput(), 'utf-8').strip().splitlines()[-1]
            if not e.isnumeric():
                self.showError("Could not connect to the network.", "'%s' is not a number." % e)
                print("'%s' is not a number." % e)
                return # bad
            try:
                self.network_id = int(e)
            except:
                self.showError("Could not connect to the network.", "\
We don't know why this happened.")
                print("returned non-zero exit code")
                return # bad
            p.setArguments(["set_network", str(self.network_id), "ssid" if ssid else "bssid", '"' + (ssid if ssid else bssid) + '"'])
            print(p.program() + " " + " ".join(p.arguments()))
            p.start()
            p.waitForFinished()
            out = str(p.readAllStandardOutput(), 'utf-8')
            if "OK" not in out:
                self.showError("Could not connect to the network.",
                               """Information for debuggers: """ + out)
                return # bad
            if "PSK" in flags:
                self.set_network_password()
            else:
                p.setArguments(["set_network", str(self.network_id), "key_mgmt", "NONE"])
            print(p.program() + " " + " ".join(p.arguments()))
            p.start()
            p.waitForFinished()
            out = str(p.readAllStandardOutput(), 'utf-8')
            if "OK" not in out:
                self.showError("Could not connect to the network. Please check the password.",
                               """Information for debuggers: """ + out)
                return # not good
            p.setArguments(["enable_network", str(self.network_id)])
            print(p.program() + " " + " ".join(p.arguments()))
            p.start()
            p.waitForFinished()
            lastout = str(p.readAllStandardOutput(), 'utf-8')
            if "OK" in lastout:
                p.setArguments(["save_config"])
                print(p.program() + " " + " ".join(p.arguments()))
                p.start()
                p.waitForFinished()
                return # good
            else:
                self.showError("Could not connect to the network. Please check the password.",
                               """Information for debuggers: """ + lastout)
                return # not good

    def _showAbout(self):
        print("showDialog")
        msg = QMessageBox()
        msg.setWindowTitle("Network")
        msg.setIconPixmap(QPixmap(os.path.dirname(__file__) + "/Resources/Network.png").scaledToWidth(64, Qt.SmoothTransformation))
        candidates = ["COPYRIGHT", "COPYING", "LICENSE"]
        for candidate in candidates:
            if os.path.exists(os.path.dirname(__file__) + "/" + candidate):
                with open(os.path.dirname(__file__) + "/" + candidate, 'r') as file:
                    data = file.read()
                msg.setDetailedText(data)
        msg.setText("<h3>Network</h3>")
        msg.setInformativeText("A simple QSystemTrayIcon application to select the wireless network using <a href='https://www.freebsd.org/cgi/man.cgi?wpa_cli'>wpa_cli</a><br><br><a href='https://github.com/helloSystem/Utilities'>https://github.com/helloSystem/Utilities</a>")
        msg.exec()

    def showError(self, text, detailed_text=""):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Critical)
        msg.setWindowTitle("Error")
        msg.setText(text)
        if detailed_text != "":
            msg.setDetailedText(detailed_text)
        msg.exec()

    def showTODO(self, detailed_text=""):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Information)
        msg.setWindowTitle("Developer Preview")
        msg.setText("This application is a preview for developers.<br>It is not fully functional yet.")
        msg.setDetailedText("Please see https://github.com/helloSystem/Utilities if you would like to contribute.\n\n" + detailed_text)
        msg.exec()

    def request_network_password(self, ssid: str, bssid: str) -> tuple[str, bool]:
        dialog = PasswordRequestDialog("<h4>Please enter the password for the \"%s\" network:</h4>" % ssid if ssid else bssid)
        dialog.setWindowTitle("Wireless network password")

        ok, password = dialog.get_password()
        if not ok:
            print("User did not click OK in password dialog")

        return password, ok

    def set_network_password(self):
        ssid = getattr(self.wirelessGroup.checkedAction(), "ssid")
        bssid = getattr(self.wirelessGroup.checkedAction(), "bssid")
        flags = getattr(self.wirelessGroup.checkedAction(), "flags")
        password, ok = self.request_network_password(ssid, bssid)

        if not ok:
            self.check_network_password = False
            return  # Don't try to connect to a network if it has been cancelled.

        p = QProcess()
        p.setProgram("wpa_cli")
        p.setArguments(["set_network", str(self.network_id), "key_mgmt", flags.split(" ")[0]])
        p.start()
        p.waitForFinished()

        p.setArguments(["set_network", str(self.network_id), "psk", '"' + password + '"'])
        print(p.program() + " " + " ".join(p.arguments()))
        p.start()
        p.waitForFinished()

        # Not really a way to tell if authentication failure occurred
        if "FAIL" in str(p.readAllStandardOutput(), 'utf-8'):
            print("Failure while setting network password")


# https://forum.qt.io/post/367830
class NetworkItem(QWidget):

    #def __init__(self, parent: QWidget, action: QAction, text: str, checked:bool,
    # password_protected: bool):
    def __init__(self, parent: QWidget, action: QAction, password_protected: bool):
        super().__init__(parent)

        self.proxyStyle = QProxyStyle("panda")

        self.action = action
        #self.text = text
        #self.checked = checked

        self.layout = QHBoxLayout()
        self.layout.setAlignment(Qt.AlignTrailing)
        self.layout.setContentsMargins(0, 0, 10, 0)

        self.lock_label = QLabel()
        self.lock_label.setPixmap(QIcon.fromTheme("network-wireless-encrypted-symbolic").pixmap(QSize(14, 14)))
        self.lock_label.setVisible(password_protected)
        self.layout.addWidget(self.lock_label)
        self.signal_label = QLabel()
        self.signal_label.setPixmap(QIcon.fromTheme("network-wireless-100").pixmap(QSize(14, 14)))
        self.layout.addWidget(self.signal_label)

        self.setLayout(self.layout)
        self.setMouseTracking(True)

    def set_password_protected(self, password_protected: bool):
        self.lock_label.setVisible(password_protected)

    def set_signal_level(self, signal_level: int):
        self.signal_label.setPixmap(QIcon.fromTheme(get_icon_for_signal_level(signal_level)).pixmap(QSize(14, 14)))

    def minimumSizeHint(self):
        opt = QStyleOptionMenuItem()
        opt.initFrom(self)
        opt.menuHasCheckableItems = True
        contentSize = self.fontMetrics().size(Qt.TextSingleLine | Qt.TextShowMnemonic, self.action.text())
        return self.style().sizeFromContents(QStyle.CT_MenuItem, opt, contentSize, self)\
            + QSize(self.layout.sizeHint().width(), 0)

    def paintEvent(self, e: QPaintEvent):
        p = QPainter(self)
        p.setFont(self.parent().font())
        opt = QStyleOptionMenuItem()
        QMenu.initStyleOption(self.parent(), opt, self.action)
        #opt.initFrom(self.parent())
        #opt.text = self.text
        #opt.menuHasCheckableItems = True
        #opt.checked = self.checked
        opt.checkType = QStyleOptionMenuItem.NonExclusive
        #opt.menuItemType = QStyleOptionMenuItem.Normal
        #opt.font = self.action.font().resolve(self.parent().font())
        #opt.fontMetrics = QFontMetrics(opt.font)
        #opt.palette = self.parent().palette()

        #if self.rect().contains(self.mapFromGlobal(self.cursor().pos())):
        #    opt.state |= QStyle.State_Selected

        self.proxyStyle.drawControl(QStyle.CE_MenuItem, opt, p, self)


class PasswordRequestDialog(QDialog):
    def __init__(self, text: str):
        super().__init__()

        self.layout = QGridLayout()
        self.layout.setHorizontalSpacing(15)
        self.layout.setSizeConstraint(QLayout.SetFixedSize)

        self.icon_label = QLabel()
        self.icon_label.setPixmap(QPixmap(os.path.dirname(__file__) + "/Resources/Network.png").scaledToWidth(64, Qt.SmoothTransformation))

        self.text_label = QLabel()
        self.text_label.setMaximumWidth(300)
        self.text_label.setContentsMargins(0, 5, 0, 0)
        self.text_label.setText(text)
        self.text_label.setWordWrap(True)

        self.password_label = QLabel()
        self.password_label.setText("Password:")

        self.password_line_edit = QLineEdit()
        self.password_line_edit.setEchoMode(QLineEdit.Password)
        self.password_line_edit.textChanged.connect(self.password_changed)
        self.password_line_edit.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.show_password_checkbox = QCheckBox()
        self.show_password_checkbox.setChecked(True)
        self.show_password_checkbox.setText("Show password")
        self.show_password_checkbox.stateChanged.connect(self.show_password_changed)

        self.buttons_layout = QHBoxLayout()
        self.buttons_layout.setContentsMargins(0, 10, 0, 0)
        self.buttons_layout.setSpacing(10)
        self.buttons_layout.setSizeConstraint(QLayout.SetFixedSize)

        self.cancel_button = QPushButton()
        self.cancel_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.cancel_button.setText("Cancel")
        self.cancel_button.clicked.connect(self.reject)

        self.connect_button = QPushButton()
        self.connect_button.setEnabled(False)
        self.connect_button.setText("Connect")
        self.connect_button.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.connect_button.clicked.connect(self.accept)

        self.buttons_layout.addWidget(self.cancel_button)
        self.buttons_layout.addWidget(self.connect_button)

        self.layout.addWidget(self.icon_label, 0, 0, Qt.AlignTop)
        self.layout.addWidget(self.text_label, 0, 1, 1, 2, Qt.AlignTop)
        self.layout.addWidget(self.password_label, 1, 1, Qt.AlignTop)
        self.layout.addWidget(self.password_line_edit, 1, 2, Qt.AlignTop)
        self.layout.addWidget(self.show_password_checkbox, 2, 2, Qt.AlignTop)
        self.layout.addLayout(self.buttons_layout, 3, 2, Qt.AlignTrailing)

        self.setLayout(self.layout)
        self.setModal(True)
        self.setSizeGripEnabled(False)

    def get_password(self) -> tuple[bool, str]:
        self.exec()

        return self.result(), self.password_label.text()

    def password_changed(self, password: str):
        self.connect_button.setEnabled(len(password) > 8)

    def show_password_changed(self, state: int):
        self.password_line_edit.setEchoMode(QLineEdit.Password if state else QLineEdit.Normal)


if __name__ == "__main__":

    # Simple singleton:
    # Ensure that only one instance of this application is running by trying to kill the other ones
    p = QProcess()
    p.setProgram("pkill")
    p.setArguments(["-f", os.path.abspath(__file__)])
    cmd = p.program() + " " + " ".join(p.arguments())
    print(cmd)
    p.start()
    p.waitForFinished()

    # https://github.com/helloSystem/ISO/issues/330
    # This requires ifconfig to be setuid so that normal users can run it
    p.setProgram("ifconfig")
    p.setArguments(["wlan0", "down"])
    print(p.program() + " " + " ".join(p.arguments()))
    p.start()
    p.waitForFinished()
    p.setArguments(["wlan0", "up"])
    print(p.program() + " " + " ".join(p.arguments()))
    p.start()
    p.waitForFinished()

    app = QApplication(sys.argv)
    app.setQuitOnLastWindowClosed(False)
    NM = NetworkMenu()
    sys.exit(app.exec_())
